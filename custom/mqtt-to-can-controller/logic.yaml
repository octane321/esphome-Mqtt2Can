interval:
  - interval: 120s
    then:
      - lambda: id(can_ack_counter) = 0;                          // Reset ACK counter for test inverter ACK
          
  - interval: 100ms
    then:
      # Start CAN Handling
      - if:
          condition:
            lambda: |-
              
              if (id(can_ack_counter) < 20) {                     // Inverter ACK ? => CANBUS ON
                
                id(can_ack_counter)++;                            // CANBUS ACK counter ++
                id(can_msg_counter)++;                            // CANBUS MSG counter ++
                return true;                                      // Condition OK
                
              }
              else if (id(can_bus_status).state == false) {       // CANBUS already OFF ?
                
                return false;                                     // Nothing to do
                
              }
              else {
              
                id(can_bus_status).publish_state(false);          // Set CANBUS Status to OFF

                ESP_LOGI("main", "No rx can 0x305 reply, Inverter not connected/responding...");
                return false;                                     // Condition NOK
                
              }

          then:
            - if: # 0x359 - Protection Alarms, Warning and Flags ( PYLON / PYLON + )
                condition:
                  lambda: return ((id(can_msg_counter) == 1) & ((id(can_protocol).active_index() == 1) | (id(can_protocol).active_index() == 2)));
                then:
                  canbus.send:
                    can_id: 0x359
                    data: !lambda |-
                      
                      // +---------------------------+
                      // | JK-BMS errors bitmask     |
                      // +---------------------------+
                      
                      // 0x8B 0x00 0x00: Battery warning message              0000 0000 0000 0000
                      //
                      // Bit 0    Low capacity                                1 (alarm), 0 (normal)    warning
                      // Bit 1    Power tube overtemperature                  1 (alarm), 0 (normal)    alarm
                      // Bit 2    Charging overvoltage                        1 (alarm), 0 (normal)    alarm
                      // Bit 3    Discharging undervoltage                    1 (alarm), 0 (normal)    alarm
                      // Bit 4    Battery over temperature                    1 (alarm), 0 (normal)    alarm
                      // Bit 5    Charging overcurrent                        1 (alarm), 0 (normal)    alarm
                      // Bit 6    Discharging overcurrent                     1 (alarm), 0 (normal)    alarm
                      // Bit 7    Cell pressure difference                    1 (alarm), 0 (normal)    alarm
                      // Bit 8    Overtemperature alarm in the battery box    1 (alarm), 0 (normal)    alarm
                      // Bit 9    Battery low temperature                     1 (alarm), 0 (normal)    alarm
                      // Bit 10   Cell overvoltage                            1 (alarm), 0 (normal)    alarm
                      // Bit 11   Cell undervoltage                           1 (alarm), 0 (normal)    alarm
                      // Bit 12   309_A protection                            1 (alarm), 0 (normal)    alarm
                      // Bit 13   309_A protection                            1 (alarm), 0 (normal)    alarm
                      // Bit 14   Reserved
                      // Bit 15   Reserved
                      //
                      // Examples:
                      // 0x0001 = 00000000 00000001: Low capacity alarm
                      // 0x0002 = 00000000 00000010: MOS tube over-temperature alarm
                      // 0x0003 = 00000000 00000011: Low capacity alarm AND power tube over-temperature alarm
                      
                      // +---------------------------+
                      // | Protection : byte 0 and 1 |
                      // +---------------------------+
                      
                      uint8_t can_mesg[] = {0, 0, 0, 0, 0, 0, 0, 0};

                      // JK-BMS alarm ?
                      if (id(bms${bms}_errors_bitmask).state > 1) {
                         uint16_t jk_errormask = id(bms${bms}_errors_bitmask).state;

                         if ((jk_errormask & 0x04) | (jk_errormask & 0x80) | (jk_errormask & 0x400)) {                 // Hight.Voltage.Alarm JK bit 2,7,10
                            can_mesg[0] = 0x02;                                                                        // byte0_bit1 (0x02 = bin 10)
                            id(alarm_status) = "OVP";
                            ESP_LOGI("main", "Hight.Voltage.Alarm JK bit 2,7,10 - can_msg[0] : %x", can_mesg[0]);
                         }
                         if ((jk_errormask & 0x08) | (jk_errormask & 0x800)) {                                         // Low.Voltage.Alarm JK bit 3,11 
                            can_mesg[0] = can_mesg[0] | 0x04;                                                          // byte0_bit2 (0x04 = bin 100)
                            id(alarm_status) = "UVP";
                            ESP_LOGI("main", "Low.Voltage.Alarm JK bit 3,11 - can_msg[0] : %x", can_mesg[0]);
                         }
                         if ((jk_errormask & 0x02) | (jk_errormask & 0x10) | (jk_errormask & 0x100)) {                 // Hight.Temp.Alarm JK bit 1,4,8
                            can_mesg[0] = can_mesg[0] | 0x08;                                                          // byte0_bit3 (0x08 = bin 1000)
                            id(alarm_status) = "OTP";
                            ESP_LOGI("main", "Hight.Temp.Alarm JK bit 1,4,8 - can_msg[0] : %x", can_mesg[0]);
                         }
                         if ((jk_errormask & 0x200)) {                                                                 // Low.Temp.Alarm JK bit 9
                            can_mesg[0] = can_mesg[0] | 0x10;                                                          // byte0_bit4 (0x10 = bin 10000)
                            id(alarm_status) = "UTP";
                            ESP_LOGI("main", "Low.Temp.Alarm JK bit 9 - can_msg[0] : %x", can_mesg[0]);
                         }
                         if ((jk_errormask & 0x40)) {                                                                  // Discharge.Over.Current JK bit 6
                            can_mesg[0] = can_mesg[0] | 0x80;                                                          // byte0_bit7 (0x80 = bin 10000000)
                            id(alarm_status) = "DOCP";
                            ESP_LOGI("main", "Discharge.Over.Current JK bit 6 - can_msg[0] : %x", can_mesg[0]);
                         }
                         if ((jk_errormask & 0x20)) {                                                                  // Charge.Over.Current JK bit 5
                            can_mesg[1] = 0x01;                                                                        // byte1_bit0 (0x01 = bin 1)
                            id(alarm_status) = "COCP";
                            ESP_LOGI("main", "Charge.Over.Current JK bit 5 - can_msg[1] : %x", can_mesg[1]);
                         }
                         if ((jk_errormask & 0x1000) | (jk_errormask & 0x2000)) {                                      // BMS internal error JK bit 12,13
                            can_mesg[1] = can_mesg[1] | 0x08;                                                          // byte1_bit3 (0x08 = bin 1000)
                            id(alarm_status) = "BMS";
                            ESP_LOGI("main", "BMS internal error JK bit 12,13 - can_msg[1] : %x", can_mesg[1]);
                         }
                         if ((jk_errormask & 0x80)) {                                                                  // Cell Imbalance JK bit 7
                            can_mesg[1] = can_mesg[1] | 0x10;                                                          // byte1_bit4 (0x10 = bin 10000)
                            ESP_LOGI("main", "Cell Imbalance JK bit 7 - can_msg[1] : %x", can_mesg[1]);
                         }
                      }
                      // No Alarm
                      else id(alarm_status) = "NoAlarm";

                      // +---------------------------+
                      // | Warning : byte 2 and 3    |
                      // +---------------------------+
                      
                      can_mesg[2] = 0x00;               // byte2 (JK-BMS infos not available)
                      can_mesg[3] = 0x00;               // byte3 (JK-BMS infos not available)
                      
                      // +---------------------------+
                      // | Flags : byte 4 to 7       |
                      // +---------------------------+
                      
                      int batt_capacity = id(bms${bms}_battery_capacity).state;
                      int batt_module;

                      if (batt_capacity <= 100) batt_module = 1;
                      else if (batt_capacity <= 200) batt_module = 2;
                      else if (batt_capacity <= 300) batt_module = 3;
                      else if (batt_capacity <= 400) batt_module = 4;
                      else if (batt_capacity <= 500) batt_module = 5;
                      else if (batt_capacity <= 600) batt_module = 6;
                      else if (batt_capacity <= 700) batt_module = 7;
                      else batt_module = 8;
                      
                      can_mesg[4] = batt_module;        // byte4 - Module in parallel (max 8)
                      can_mesg[5] = 0x00;               // byte5
                      can_mesg[6] = 0x00;               // byte6
                      can_mesg[7] = 0x00;               // byte7 - DIP switches 1,3 10000100 0x84
                      
                      ESP_LOGI("main", "send can id: 0x359 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                      return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                      
            - if: # 0x35A - Protection Alarms and Warning ( SMA / Victron )
                condition:
                  lambda: return ((id(can_msg_counter) == 1) & ((id(can_protocol).active_index() == 3) | (id(can_protocol).active_index() == 4)));
                then:
                  canbus.send:
                    can_id: 0x35A
                    data: !lambda |-
                      
                      // +---------------------------+
                      // | Protection : byte 0,1,2,3 |
                      // +---------------------------+
                      
                      uint8_t can_mesg[] = {0, 0, 0, 0, 0, 0, 0, 0};

                      // JK-BMS alarm ?
                      if (id(bms${bms}_errors_bitmask).state > 1) {
                         uint16_t jk_errormask = id(bms${bms}_errors_bitmask).state;

                         if ((jk_errormask & 0x04) | (jk_errormask & 0x80) | (jk_errormask & 0x400)) {                 // Hight.Voltage.Alarm JK bit 2,7,10
                            can_mesg[0] = 0x04;                                                                        // byte0_bit2 (0x04 = bin 100)
                            id(alarm_status) = "OVP";
                            ESP_LOGI("main", "Hight.Voltage.Alarm JK bit 2,7,10 - can_msg[0] : %x", can_mesg[0]);
                         }
                         if ((jk_errormask & 0x08) | (jk_errormask & 0x800)) {                                         // Low.Voltage.Alarm JK bit 3,11
                            can_mesg[0] = can_mesg[0] | 0x10;                                                          // byte0_bit4 (0x10 = bin 10000)
                            id(alarm_status) = "UVP";
                            ESP_LOGI("main", "Low.Voltage.Alarm JK bit 3,11 - can_msg[0] : %x", can_mesg[0]);
                         }
                         if ((jk_errormask & 0x02) | (jk_errormask & 0x10) | (jk_errormask & 0x100)) {                 // Hight.Temp.Alarm JK bit 1,4,8
                            can_mesg[0] = can_mesg[0] | 0x40;                                                          // byte0_bit6 (0x40 = bin 1000000)
                            id(alarm_status) = "OTP";
                            ESP_LOGI("main", "Hight.Temp.Alarm JK bit 1,4,8 - can_msg[0] : %x", can_mesg[0]);
                         }
                         if ((jk_errormask & 0x200)) {                                                                 // Low.Temp.Alarm JK bit 9
                            can_mesg[1] = 0x01;                                                                        // byte1_bit0 (0x01 = bin 1)
                            id(alarm_status) = "UTP";
                            ESP_LOGI("main", "Low.Temp.Alarm JK bit 9 - can_msg[1] : %x", can_mesg[1]);
                         }
                         if ((jk_errormask & 0x40)) {                                                                  // Discharge.Over.Current JK bit 6
                            can_mesg[1] = can_mesg[1] | 0x40;                                                          // byte1_bit6 (0x40 = bin 1000000)
                            id(alarm_status) = "DOCP";
                            ESP_LOGI("main", "Discharge.Over.Current JK bit 6 - can_msg[1] : %x", can_mesg[1]);
                         }
                         if ((jk_errormask & 0x20)) {                                                                  // Charge.Over.Current JK bit 5
                            can_mesg[2] = 0x01;                                                                        // byte2_bit0 (0x01 = bin 1)
                            id(alarm_status) = "COCP";
                            ESP_LOGI("main", "Charge.Over.Current JK bit 5 - can_msg[2] : %x", can_mesg[2]);
                         }
                         if ((jk_errormask & 0x1000) | (jk_errormask & 0x2000)) {                                      // BMS.Internal.Error JK bit 12,13
                            can_mesg[2] = can_mesg[2] | 0x40;                                                          // byte2_bit6 (0x40 = bin 1000000)
                            id(alarm_status) = "BMS";
                            ESP_LOGI("main", "BMS internal error JK bit 12,13 - can_msg[2] : %x", can_mesg[2]);
                         }
                         if ((jk_errormask & 0x80)) {                                                                  // Cell.Imbalance JK bit 7
                            can_mesg[3] = 0x01;                                                                        // byte3_bit0 (0x01 = bin 1)
                            ESP_LOGI("main", "Cell Imbalance JK bit 7 - can_msg[3] : %x", can_mesg[3]);
                         }
                      }
                      // No Alarm
                      else id(alarm_status) = "NoAlarm";
                      
                      ESP_LOGI("main", "send can id: 0x35A hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                      return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                      
            - if: # 0x351 - BMS instruction : Charge Volts, Charge Amps, Discharge Amps, Min voltage
                condition:
                  lambda: return id(can_msg_counter) == 2;
                then:
                  canbus.send:
                    can_id: 0x351
                    data: !lambda |-
                      
                      // +-----------------------------------------------+
                      // | Cut-off Current Charging Logic for LFP        |
                      // +-----------------------------------------------+
                      
                      // Warning : information from JK BMS is not available immediately after boot
                      
                      // JK-BMS Alarm !
                      if (id(bms${bms}_errors_bitmask).state > 1) id(charge_status) = "Alarm";
                      // JK-BMS Alarm ended
                      else if ((id(charge_status) == "Alarm") & (id(bms${bms}_errors_bitmask).state < 2)) {
                        if (id(eoc) == true) id(charge_status) = "EOC";
                        else id(charge_status) = "Wait";
                      }
                      // Float
                      else if ((id(charge_status) == "EOC") & (id(can_switch_float).state)) id(charge_status) = "Float";
                      // No Float => EOC
                      else if ((id(charge_status) == "Float") & (!id(can_switch_float).state)) id(charge_status) = "EOC";
                      // No Force Bulk => Wait
                      else if ((id(charge_status) == "Force Bulk") & (!id(can_switch_force_bulk).state)) id(charge_status) = "Wait";
                      // No Balancing => Wait
                      else if ((id(charge_status) == "Balancing") & (!id(bms${bms}_switch_balancing).state)) id(charge_status) = "Wait";
                      
                      // +-----------------------------------------------+
                      // | Charge ON : BMS and CAN charging switch is ON |
                      // +-----------------------------------------------+
                      else if ((id(bms${bms}_switch_charging).state) & (id(can_switch_charging).state)) {
                      
                        // Variables
                        float cell_bulk_v = (id(bulk_voltage).state / id(bms${bms}_cell_count).state);
                        float cell_rebulk_v = (id(rebulk_voltage).state / id(bms${bms}_cell_count).state);
                        float cell_absorption_offset_v = (id(absorption_offset).state / id(bms${bms}_cell_count).state);
                        
                        // Force Bulk Logic
                        if (id(can_switch_force_bulk).state) {
                          // Stop Force Bulk when cells equalizing (charging ends when cells are equalized)
                          if (id(bms${bms}_equalizing_state).state) {
                            id(charge_status) = "Balancing";
                            id(can_switch_force_bulk).turn_off();
                          }
                          // Force Bulk
                          else id(charge_status) = "Force Bulk";
                        }
                        
                        // Rebulk Logic (eg: Max Cell V. <= 3.3V)
                        else if (id(bms${bms}_max_cell_voltage).state <= cell_rebulk_v) id(charge_status) = "Bulk";
                        
                        // Charging Logic
                        else if ((id(charge_status) == "Wait") | (id(charge_status) == "Bulk") | (id(charge_status) == "Force Bulk") | (id(charge_status) == "Balancing") | (id(charge_status) == "Absorption")) {
                        
                          // Charging
                          if (id(current).state >= 0) {

                            float cv_min = 3.37;
                            float cv_max = 3.65;
                            float cutoff_current = (id(bms${bms}_battery_capacity).state * 0.05 * (cell_bulk_v - cv_min) / (cv_max - cv_min));
                            float cutoff_voltage = (cv_min + (cv_max - cv_min)/(0.05 + cell_absorption_offset_v) * (id(current).state / id(bms${bms}_battery_capacity).state));
                            
                            ESP_LOGI("main", "Cut-Off Current : %f", cutoff_current);
                            ESP_LOGI("main", "Cut-Off Voltage : %f", cutoff_voltage);
                          
                            // Stop Charging
                            if ((id(current).state <= cutoff_current) & (id(bms${bms}_max_cell_voltage).state >= cutoff_voltage)) {
                            
                              // End Of Charge
                              if ((!id(bms${bms}_equalizing_state).state)) id(charge_status) = "EOC";
                            
                            }
                            // Start Charging
                            else {
                              
                              // With the "Auto Charge Current Control", the current is reduced automatically if "max_cell_voltage" approaches BMS OVPR
                              
                              // Balancing : the BMS is equalizing the cells
                              if (id(bms${bms}_equalizing_state).state) id(charge_status) = "Balancing";
                              // Absorption : Max Cell V. >= Cell Absorption V.
                              else if (id(bms${bms}_max_cell_voltage).state >= (cell_bulk_v - cell_absorption_offset_v)) id(charge_status) = "Absorption";
                              // Bulk
                              else id(charge_status) = "Bulk";
                          
                            }
                          }
                          // Discharging (!= "EOC" | != "Float")
                          else if (id(bms${bms}_max_cell_voltage).state < (cell_bulk_v - cell_absorption_offset_v)) id(charge_status) = "Bulk";
                        }
                      }
                      // Charge OFF
                      else id(charge_status) = "Wait";

                      // +--------------------------------------+
                      // | Charge values                        |
                      // +--------------------------------------+

                      // Bulk Charge
                      if ((id(charge_status) == "Bulk") | (id(charge_status) == "Force Bulk") | (id(charge_status) == "Balancing") | (id(charge_status) == "Absorption")) {
                        id(charging_v) = (id(bulk_voltage).state + ${inverter_offset_v});
                        id(charging_a) = id(auto_charge_current_final).state;
                        id(eoc) = false;                                                            // SOC 100% can't be sent
                      }
                      // Float Charge
                      else if (id(charge_status) == "Float") {
                        id(charging_v) = (id(float_voltage).state + ${inverter_offset_v});
                        id(charging_a) = id(auto_charge_current_final).state;
                      }
                      // Wait : Stop Charging
                      else if (id(charge_status) == "Wait") {
                        id(charging_v) = (id(rebulk_voltage).state);                                // Rebulk V.
                        id(charging_a) = 0;
                      }
                      // End Of Charge (EOC) : Stop Charging
                      else if (id(charge_status) == "EOC") {
                        id(charging_v) = (id(rebulk_voltage).state);                                // Rebulk V.
                        id(charging_a) = 0;
                        id(eoc) = true;                                                             // SOC 100% can be sent
                      }
                      
                      // +--------------------------------------+
                      // | Discharge values                     |
                      // +--------------------------------------+

                      // Stop Discharging if BMS or ESP32 switch is OFF
                      if ((!id(bms${bms}_switch_discharging).state) | (!id(can_switch_discharging).state)) id(discharging_a) = 0;
                      // Stop Discharging if battery voltage is low
                      else if (id(total_voltage).state <= ${min_discharge_v}) id(discharging_a) = 0;
                      // Allow Discharging
                      else id(discharging_a) = id(auto_discharge_current_final).state;

                      // +--------------------------------------+
                      // | Preventive Alarms Logic              |
                      // +--------------------------------------+

                      // High Temp Protection - Stop Charging and Discharging
                      if (max(id(bms${bms}_temperature_sensor_1).state, id(bms${bms}_temperature_sensor_2).state) > ${otp}){
                        id(alarm_status) = "OTP";
                      }
                      // Low Temp Protection - Stop Charging
                      else if (min(id(bms${bms}_temperature_sensor_1).state, id(bms${bms}_temperature_sensor_2).state) < ${utp}){
                        id(alarm_status) = "UTP";
                      }

                      // +--------------------------------------+
                      // | Alarm overwrite values               |
                      // +--------------------------------------+

                      ESP_LOGI("main", "Alarm Status : %s", id(alarm_status).c_str());
                      
                      // Alarm : Stop Charging and Discharging
                      if ((id(alarm_status) == "OTP") | (id(alarm_status) == "BMS")){
                          id(charging_v) = (3.2 * id(bms${bms}_cell_count).state);
                          id(charging_a) = 0;
                          id(discharging_a) = 0;
                      }
                      // Alarm : Stop Charging
                      else if ((id(alarm_status) == "OVP") | (id(alarm_status) == "UTP") | (id(alarm_status) == "COCP")){
                          id(charging_v) = (3.2 * id(bms${bms}_cell_count).state);
                          id(charging_a) = 0;
                      }
                      // Alarm : Stop Discharging
                      else if ((id(alarm_status) == "UVP") | (id(alarm_status) == "DOCP")){
                          id(discharging_a) = 0;
                      }
                      
                      // +--------------------------------------+
                      // | CAN messages                         |
                      // +--------------------------------------+
                      
                      // Byte [00:01] = CVL : Charge Limit Voltage    (0.1 V)
                      // Byte [02:03] = CCL : Charge Limit Current    (0.1 A)
                      // Byte [04:05] = DCL : Discharge Limit Current (0.1 A)
                      // Byte [06:07] = DVL : Discharge Limit Voltage (0.1 V)
                      
                      uint8_t can_mesg[8];
                      
                      can_mesg[0] = uint16_t(id(charging_v) * 10) & 0xff;
                      can_mesg[1] = uint16_t(id(charging_v) * 10) >> 8 & 0xff;
                      can_mesg[2] = uint16_t(id(charging_a) * 10) & 0xff;
                      can_mesg[3] = uint16_t(id(charging_a) * 10) >> 8 & 0xff;
                      can_mesg[4] = uint16_t(id(discharging_a) * 10) & 0xff;
                      can_mesg[5] = uint16_t(id(discharging_a) * 10) >> 8 & 0xff;
                      can_mesg[6] = uint16_t(${min_discharge_v} * 10) & 0xff;
                      can_mesg[7] = uint16_t(${min_discharge_v} * 10) >> 8 & 0xff;
                      
                      // +--------------------------------------+
                      // | Publish sensor state                 |
                      // +--------------------------------------+
                      
                      if (id(charging_status).state != id(charge_status))                             //reduce mqtt publishes
                          id(charging_status).publish_state(id(charge_status));

                      if (id(requested_charge_voltage).state != id(charging_v))                       //reduce mqtt publishes
                          id(requested_charge_voltage).publish_state(id(charging_v));

                      // Logs
                      ESP_LOGI("main", "send can id: 0x351 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                      ESP_LOGI("main", "Charge Status : %s", id(charge_status).c_str());
                      return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                      
            - if: # 0x355 - Actual State of Charge (SOC), State of Health (SOH), Remaining total capacity
                condition:
                  lambda: return id(can_msg_counter) == 3;
                then:
                  canbus.send:
                    can_id: 0x355
                    data: !lambda |-
                      
                      // Byte [00:01] : State of Charge (SOC)    (1 %)
                      // Byte [02:03] : State of Health (SOH)    (1 %)
                      // Byte [04:05] : SOC high resolution      (0.01 %)
                      // Byte [06:07] : Remaining total capacity (1 Ah) (Sofar)

                      uint8_t can_mesg[8];
                      uint16_t soc;
                      uint16_t soh;

                      // SOC - Sending 100% only at the end of the absorption phase
                      if (id(state_of_charge).state < 100) soc = id(state_of_charge).state;       // SOC < 100% => Sending BMS SOC
                      else if (id(eoc) == true) soc = 100;                                        // End Of Charge => Sending 100%
                      else soc = 99;                                                              // Otherwise => Sending 99%

                      // SOH
                      soh = round(((id(bms${bms}_charging_cycles).state/${max_cycles})-1)*-100);

                      can_mesg[0] = soc & 0xff;
                      can_mesg[1] = soc >> 8 & 0xff;
                      can_mesg[2] = soh & 0xff;
                      can_mesg[3] = soh >> 8 & 0xff;
                      can_mesg[4] = (soc * 100) & 0xff;
                      can_mesg[5] = (soc * 100) >> 8 & 0xff;
                      can_mesg[6] = uint16_t(id(bms${bms}_capacity_remaining_ah).state * 10) & 0xff;
                      can_mesg[7] = uint16_t(id(bms${bms}_capacity_remaining_ah).state * 10) >> 8 & 0xff;
                      ESP_LOGI("main", "send can id: 0x355 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                      return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                      
            - if: # 0x356 - Actual Voltage / Current / Temperature / Cycles (Deye 0x305 ACK)
                condition:
                  lambda: return id(can_msg_counter) == 4;
                then:
                  canbus.send:
                    can_id: 0x356
                    data: !lambda |-
                      
                      // Byte [00:01] : Actual Voltage       (0.01 V)
                      // Byte [02:03] : Actual Current       (0.1 A)
                      // Byte [04:05] : Actual Temperature   (0.1 Â°C)
                      // Byte [06:07] : Actual Cycles number (1 cycle) (Sofar)

                      uint8_t can_mesg[8];
                      can_mesg[0] = uint16_t(id(total_voltage).state * 100) & 0xff;
                      can_mesg[1] = uint16_t(id(total_voltage).state * 100) >> 8 & 0xff;
                      can_mesg[2] = int16_t(id(current).state * 10) & 0xff;
                      can_mesg[3] = int16_t(id(current).state * 10) >> 8 & 0xff;
                      can_mesg[4] = int16_t(((id(bms${bms}_temperature_sensor_1).state + id(bms${bms}_temperature_sensor_2).state) / 2) * 10) & 0xff;
                      can_mesg[5] = int16_t(((id(bms${bms}_temperature_sensor_1).state + id(bms${bms}_temperature_sensor_2).state) / 2) * 10) >> 8 & 0xff;
                      can_mesg[6] = uint16_t(id(bms${bms}_charging_cycles).state) & 0xff;
                      can_mesg[7] = uint16_t(id(bms${bms}_charging_cycles).state) >> 8 & 0xff;    
                      ESP_LOGI("main", "send can id: 0x356 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                      return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                      
            - if: # 0x35C - Request flag to Enable/Disable: Charge, Discharge ( PYLON / PYLON + )
                condition:
                  lambda: return ((id(can_msg_counter) == 5) & ((id(can_protocol).active_index() == 1) | (id(can_protocol).active_index() == 2)));
                then:
                  canbus.send:
                    can_id: 0x35C
                    data: !lambda |-
                      uint8_t can_mesg[2];
                      can_mesg[0] = 0x00;
                      can_mesg[1] = 0x00;
                      
                      // Bit 7 : Charge enable
                      if ((id(bms${bms}_switch_charging).state) & (id(can_switch_charging).state))
                         can_mesg[0] = 0x80;
                      
                      // Bit 6 : Discharge enable
                      if ((id(bms${bms}_switch_discharging).state) & (id(can_switch_discharging).state))
                         can_mesg[0] = can_mesg[0] | 0x40;
                                            
                      ESP_LOGI("main", "send can id: 0x35C hex: %x %x", can_mesg[0], can_mesg[1]);
                      return {can_mesg[0], can_mesg[1]};
                      
            - if: # 0x70  - Actual Max Cell Temp, Min Cell Temp, Max Cell V, Min Cell V ( PYLON / PYLON + )
                condition:
                  lambda: return ((id(can_msg_counter) == 6) & (id(can_protocol).active_index() == 2));
                then:
                  canbus.send:
                    can_id: 0x70
                    data: !lambda |-
                      
                      // Byte [00:01] : Max cell temperature
                      // Byte [02:03] : Min cell temperature
                      // Byte [04:05] : Max cell voltage
                      // Byte [06:07] : Min cell voltage
                      
                      int max_cell_voltage_i = id(bms${bms}_max_cell_voltage).state * 100.0;
                      int min_cell_voltage_i = id(bms${bms}_min_cell_voltage).state * 100.0;
                      uint8_t can_mesg[8];
                      can_mesg[0] = int16_t(max(id(bms${bms}_temperature_sensor_1).state, id(bms${bms}_temperature_sensor_2).state)* 10) & 0xff;
                      can_mesg[1] = int16_t(max(id(bms${bms}_temperature_sensor_1).state, id(bms${bms}_temperature_sensor_2).state)* 10) >> 8 & 0xff;
                      can_mesg[2] = int16_t(min(id(bms${bms}_temperature_sensor_1).state, id(bms${bms}_temperature_sensor_2).state)* 10) & 0xff;
                      can_mesg[3] = int16_t(min(id(bms${bms}_temperature_sensor_1).state, id(bms${bms}_temperature_sensor_2).state)* 10) >> 8 & 0xff;
                      can_mesg[4] = max_cell_voltage_i & 0xff;
                      can_mesg[5] = max_cell_voltage_i >> 8 & 0xff;
                      can_mesg[6] = min_cell_voltage_i & 0xff;
                      can_mesg[7] = min_cell_voltage_i >> 8 & 0xff;
                      ESP_LOGI("main", "send can id: 0x70 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                      return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                      
            - if: # 0x371 - Actual Max Cell Temp ID, Min Cell Temp ID, Max Cell V ID, Min Cell ID ( PYLON / PYLON + )
                condition:
                  lambda: return ((id(can_msg_counter) == 6) & (id(can_protocol).active_index() == 2));
                then:
                  - canbus.send:
                      can_id: 0x371
                      data: !lambda |-
                        
                        // Byte [00:01] : Max cell temperature ID
                        // Byte [02:03] : Min cell temperature ID
                        // Byte [04:05] : Max cell voltage ID
                        // Byte [06:07] : Min cell voltage ID
                        
                        uint8_t can_mesg[8];

                        // Min-Max Temp. Sensor ID ?
                        if (id(bms${bms}_temperature_sensor_1).state >= id(bms${bms}_temperature_sensor_2).state){
                          can_mesg[0] = 0x01;
                          can_mesg[2] = 0x02;
                        }
                        else {
                          can_mesg[0] = 0x02;
                          can_mesg[2] = 0x01;
                        }
                        
                        can_mesg[1] = 0x00;
                        can_mesg[3] = 0x00;
                        can_mesg[4] = uint16_t(id(bms${bms}_max_voltage_cell).state) & 0xff;
                        can_mesg[5] = uint16_t(id(bms${bms}_max_voltage_cell).state) >> 8 & 0xff;
                        can_mesg[6] = uint16_t(id(bms${bms}_min_voltage_cell).state) & 0xff;
                        can_mesg[7] = uint16_t(id(bms${bms}_min_voltage_cell).state) >> 8 & 0xff;
                        ESP_LOGI("main", "send can id: 0x371 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                        return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                        
            - if: # 0x372 - Battery modules information ( Victron )
                condition:
                  lambda: return ((id(can_msg_counter) == 7) & (id(can_protocol).active_index() == 4));
                then:
                  - canbus.send:
                      can_id: 0x372
                      data: !lambda |-
                        
                        // Byte [00:01] : Nbr. of battery modules online
                        // Byte [02:03] : Nbr. of modules blocking charge
                        // Byte [04:05] : Nbr. of modules blocking discharge
                        // Byte [06:07] : Nbr. of battery modules offline
                        
                        uint8_t can_mesg[] = {0, 0, 0, 0, 0, 0, 0, 0};
                        can_mesg[0] = 0x01;

                        ESP_LOGI("main", "send can id: 0x372 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                        return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};

            - if: # 0x373 - Actual Min Cell V, Max Cell V, Min Cell Temp (Kelvin), Max Cell Temp (Kelvin) ( Victron )
                condition:
                  lambda: return ((id(can_msg_counter) == 8) & (id(can_protocol).active_index() == 4));
                then:
                  canbus.send:
                    can_id: 0x373
                    data: !lambda |-
                      
                      // Byte [00:01] : Min cell voltage
                      // Byte [02:03] : Max cell voltage
                      // Byte [04:05] : Min cell temperature
                      // Byte [06:07] : Max cell temperature
                      
                      int min_cell_voltage_i = id(bms${bms}_min_cell_voltage).state * 1000.0;
                      int max_cell_voltage_i = id(bms${bms}_max_cell_voltage).state * 1000.0;
                      int min_temp_kelvin = min(id(bms${bms}_temperature_sensor_1).state, id(bms${bms}_temperature_sensor_2).state) + 273.15;
                      int max_temp_kelvin = max(id(bms${bms}_temperature_sensor_1).state, id(bms${bms}_temperature_sensor_2).state) + 273.15;
                      
                      uint8_t can_mesg[8];
                      can_mesg[0] = min_cell_voltage_i & 0xff;
                      can_mesg[1] = min_cell_voltage_i >> 8 & 0xff;
                      can_mesg[2] = max_cell_voltage_i & 0xff;
                      can_mesg[3] = max_cell_voltage_i >> 8 & 0xff;
                      can_mesg[4] = min_temp_kelvin & 0xff;
                      can_mesg[5] = min_temp_kelvin >> 8 & 0xff;
                      can_mesg[6] = max_temp_kelvin & 0xff;
                      can_mesg[7] = max_temp_kelvin >> 8 & 0xff;
                      
                      ESP_LOGI("main", "send can id: 0x373 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                      return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                      
            - if: # 0x374 - Min cell voltage ID [ASCII] ( Victron )
                condition:
                  lambda: return ((id(can_msg_counter) == 8) & (id(can_protocol).active_index() == 4));
                then:
                  - canbus.send:
                      can_id: 0x374
                      data: !lambda |-
                        
                        int cell_id = id(bms${bms}_min_voltage_cell).state;

                        ESP_LOGI("main", "send can id: 0x374 [ASCII] Min cell voltage ID : %i", cell_id);

                        if (cell_id == 1) return {0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 2) return {0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 3) return {0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 4) return {0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 5) return {0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 6) return {0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 7) return {0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 8) return {0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 9) return {0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 10) return {0x31, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 11) return {0x31, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 12) return {0x31, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 13) return {0x31, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 14) return {0x31, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 15) return {0x31, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 16) return {0x31, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else return {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

            - if: # 0x375 - Max cell voltage ID [ASCII] ( Victron )
                condition:
                  lambda: return ((id(can_msg_counter) == 8) & (id(can_protocol).active_index() == 4));
                then:
                  - canbus.send:
                      can_id: 0x375
                      data: !lambda |-
                        
                        int cell_id = id(bms${bms}_max_voltage_cell).state;

                        ESP_LOGI("main", "send can id: 0x375 [ASCII] Max cell voltage ID : %i", cell_id);

                        if (cell_id == 1) return {0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 2) return {0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 3) return {0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 4) return {0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 5) return {0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 6) return {0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 7) return {0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 8) return {0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 9) return {0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 10) return {0x31, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 11) return {0x31, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 12) return {0x31, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 13) return {0x31, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 14) return {0x31, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 15) return {0x31, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 16) return {0x31, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else return {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

            - if: # 0x376 - Min cell temperature ID [ASCII] ( Victron )
                condition:
                  lambda: return ((id(can_msg_counter) == 8) & (id(can_protocol).active_index() == 4));
                then:
                  - canbus.send:
                      can_id: 0x376
                      data: !lambda |-
                        
                        // Min Temp. Sensor ID ?
                        if (id(bms${bms}_temperature_sensor_1).state >= id(bms${bms}_temperature_sensor_2).state){
                          ESP_LOGI("main", "send can id: 0x376 [ASCII] Min Temp. Sensor ID : 2");
                          return {0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        }
                        else {
                          ESP_LOGI("main", "send can id: 0x376 [ASCII] Min Temp. Sensor ID : 1");
                          return {0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        }

            - if: # 0x377 - Max cell temperature ID [ASCII] ( Victron )
                condition:
                  lambda: return ((id(can_msg_counter) == 8) & (id(can_protocol).active_index() == 4));
                then:
                  - canbus.send:
                      can_id: 0x377
                      data: !lambda |-
                        
                        // Max Temp. Sensor ID ?
                        if (id(bms${bms}_temperature_sensor_1).state >= id(bms${bms}_temperature_sensor_2).state){
                          ESP_LOGI("main", "send can id: 0x377 [ASCII] Max Temp. Sensor ID : 1");
                          return {0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        }
                        else {
                          ESP_LOGI("main", "send can id: 0x377 [ASCII] Max Temp. Sensor ID : 2");
                          return {0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        }

            - if: # 0x379 - Battery Installed Capacity Ah ( PYLON + / Victron, Sol-Ark, Luxpower )
                condition:
                  lambda: return ((id(can_msg_counter) == 9) & ((id(can_protocol).active_index() == 2) | (id(can_protocol).active_index() == 4)));
                then:
                  - canbus.send:
                      can_id: 0x379
                      data: !lambda |-
                        uint8_t can_mesg[] = {0, 0, 0, 0, 0, 0, 0, 0};
                        can_mesg[0] = uint16_t(id(bms${bms}_battery_capacity).state) & 0xff;
                        can_mesg[1] = uint16_t(id(bms${bms}_battery_capacity).state) >> 8 & 0xff;
                        
                        ESP_LOGI("main", "send can id: 0x379 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                        return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                        
            - if: # 0x382 - Product identification [ASCII] ( Victron )
                condition:
                  lambda: return ((id(can_msg_counter) == 10) & (id(can_protocol).active_index() == 4));
                then:
                  - canbus.send:
                      can_id: 0x382
                      data: !lambda |-
                        ESP_LOGI("main", "send can id: 0x382 [ASCII] Product : JK-BMS");
                        return {0x4A, 0x4B, 0x2D, 0x42, 0x4D, 0x53, 0x00, 0x00}; // JK-BMS

            - if: # 0x35F - Battery information ( SMA, Victron )
                condition:
                  lambda: return ((id(can_msg_counter) == 11) & ((id(can_protocol).active_index() == 3) | (id(can_protocol).active_index() == 4)));
                then:
                  - canbus.send:
                      can_id: 0x35F
                      data: !lambda |-
                        
                        //                SMA                 Victron
                        // Byte [00:01] : Bat-Type            Product ID
                        // Byte [02:03] : BMS Version         Firmware version (1.17 => HEX [01:11])
                        // Byte [04:05] : Bat-Capacity        Available Capacity Ah
                        // Byte [06:07] : Manufacturer ID     Hardware version
                        
                        uint8_t can_mesg[] = {0, 0, 0, 0, 0, 0, 0, 0};
                        can_mesg[2] = 0x01;
                        can_mesg[3] = 0x11;
                        can_mesg[4] = uint16_t(id(bms${bms}_battery_capacity).state) & 0xff;
                        can_mesg[5] = uint16_t(id(bms${bms}_battery_capacity).state) >> 8 & 0xff;
                        
                        ESP_LOGI("main", "send can id: 0x35F hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                        return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                        
            - if: # 0x35E - Manufacturer name
                condition:
                  lambda: return id(can_msg_counter) == 12;
                then:
                  - canbus.send:
                      can_id: 0x35E
                      data: !lambda |-
                        
                        if (id(can_bms_name).active_index() == 0){
                           ESP_LOGI("main", "send can id: 0x35E ASCII : GENERAL");
                           return {0x47, 0x45, 0x4E, 0x45, 0x52, 0x41, 0x4C, 0x20}; // GENERAL
                        }
                        if (id(can_bms_name).active_index() == 1){
                           ESP_LOGI("main", "send can id: 0x35E ASCII : PYLON");
                           return {0x50, 0x59, 0x4C, 0x4F, 0x4E, 0x20, 0x20, 0x20}; // PYLON ( recognized by Deye, display PYLON name and SOH )
                        }
                        else if (id(can_bms_name).active_index() == 2){
                           ESP_LOGI("main", "send can id: 0x35E ASCII : GOODWE");
                           return {0x47, 0x4F, 0x4F, 0x44, 0x57, 0x45, 0x20, 0x20}; // GOODWE
                        }
                        else if (id(can_bms_name).active_index() == 3){
                           ESP_LOGI("main", "send can id: 0x35E ASCII : SHEnergy");
                           return {0x53, 0x48, 0x45, 0x6E, 0x65, 0x72, 0x67, 0x79}; // SHEnergy (SEPLOS)
                        }
                        else {
                           ESP_LOGI("main", "send can id: 0x35E ASCII : PYLON");
                           return {0x50, 0x59, 0x4C, 0x4F, 0x4E, 0x20, 0x20, 0x20}; // PYLON
                        }

                    # Reset counter
                  - lambda: id(can_msg_counter) = 0;
